<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Recuerdos</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <audio id="musica" autoplay loop muted playsinline>
    <source src="SE_ME_HA_OLVIDADO.mp3" type="audio/mpeg">
  </audio>
  <!-- Estilos -->
  <style>
    :root{
        --bg1:#ffdde1;
        --bg2:#ee9ca7;
        --panel:#fff5f7;
        --accent:#ff5e7e;
        --muted:#8e7d82;
    }

    html, body {
  margin: 0;
  padding: 0;
  min-height: 100dvh;
  overflow-x: hidden;
  overflow-y: auto;
}

/* 1) Quita el padding del body: usa margen en el card */
body {
  background: linear-gradient(180deg, var(--bg1), var(--bg2));
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Poppins', sans-serif;
  color: #ddd;
  box-sizing: border-box;
}

/* 2) M치rgenes laterales del card */
#card {
  position: relative;
  width: 100%;
  max-width: 400px;
  margin: 0 12px;             /* <- antes estaba en body */
  color: #fff5f7;
  background-color: #5b2b36;
  padding: 20px;
  border-radius: 15px;
  text-align: center;
  box-sizing: border-box;
  position: relative;
  isolation: isolate;          /* crea su propio stacking context */
  overflow: hidden;            /* evita desbordes decorativos */
}

/* 3) Centrado real en viewport y por detr치s del card */
#screen {
  position: absolute;
  z-index: 0;
  pointer-events: none;

  font-family: monospace;
  white-space: pre;
  text-align: center;
  line-height: 0.65;
  font-size: 10px;
  color: var(--accent);

  max-width: 100%;
  max-height: 100%;
  overflow: hidden;
}


/* el contenido del card siempre por encima */
#card * {
  position: relative;
  z-index: 1;
}

header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin-bottom: 15px;
}

header h2 {
  margin: 0;
  color: var(--accent);
}

#musicBtn{
  background:var(--accent);
  border:none;
  color:#fff;
  font-size:20px;
  border-radius:50%;
  width:42px;
  height:42px;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 4px 12px rgba(255,94,126,0.4);
  transition:all .25s;
  }
  #musicBtn:hover{transform:scale(1.1);background:#ff7792}

    #card p {
      margin: 10px 0;
      font-size: 14px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
<div id="card">
  <header>
    <h2>Mis recuerdos</h2>
    <button id="musicBtn">游댆</button>
  </header>
  
  <p>Recuerdo el d칤a en que nos conocimos en persona, en la biblioteca; yo me hice el guay con mi juguetito friki.</p>  
  <p>Recuerdo nuestro primer beso; los nervios se sent칤an en el ambiente.</p>
  <p>Recuerdo los d칤as de descanso en el coche; no se porque, hacia mucho calor.</p>
  <p>Recuerdo la primera vez que dormimos juntos; a pesar de que la cama era peque침ita, dorm칤 tan agusto como si te conociera de toda la vida.</p>
  <p>Recuerdo el d칤a que conoc칤 a tu familia; casi me muero de verg칲enza en el ascensor.</p>
  <p>Recuerdo nuestras salidas a comer sushi; tu cara de felicidad era indescriptible y me hac칤a sonre칤r sin raz칩n.</p>
  <p>Recuerdo nuestro primer viaje juntos; los moros abundaban por la zona.</p>
  <p>Y por todos esos recuerdos, por todos los momentos que hemos compartido, es que te quiero con todo mi coraz칩n.</p>
</div>
 
<pre id="screen"></pre>

<script>
(()=>{

const chars = " .:-=+*#%@";     // mapa de brillo (de oscuro a claro)
const screen = document.getElementById('screen');

let W = 80, H = 40;
let running = true;

function F(x,y,z){
  // ecuaci칩n impl칤cita que define la "superficie" del coraz칩n
  const a = x*x + 2.25*y*y + z*z - 1.0;
  return a*a*a - x*x*z*z*z - (9.0/80.0) * y*y * z*z*z;
}

function rotatePoint(p, ax, ay){
  // rota (p) primero alrededor de Y (ay) y luego alrededor de X (ax)
  const cosy = Math.cos(ay), siny = Math.sin(ay);
  const x1 = cosy*p.x + siny*p.z;
  const z1 = -siny*p.x + cosy*p.z;
  const cosx = Math.cos(ax), sinx = Math.sin(ax);
  const y2 = cosx*p.y - sinx*z1;
  const z2 = sinx*p.y + cosx*z1;
  return {x:x1,y:y2,z:z2};
}

function rotateVecInverse(v, ax, ay){
  // convierte un vector gradiente desde coords del objeto a coords "mundo"
  // aplicando Rx^T y Ry^T (rotaciones inversas)
  const cosx = Math.cos(-ax), sinx = Math.sin(-ax);
  const y1 = cosx*v.y - sinx*v.z;
  const z1 = sinx*v.y + cosx*v.z;
  const x1 = v.x;
  const cosy = Math.cos(-ay), siny = Math.sin(-ay);
  const x2 = cosy*x1 + siny*z1;
  const z2 = -siny*x1 + cosy*z1;
  return {x:x2,y:y1,z:z2};
}

function gradientAt(x,y,z){
  const eps = 1e-2;
  const dx = (F(x+eps,y,z) - F(x-eps,y,z)) / (2*eps);
  const dy = (F(x,y+eps,z) - F(x,y-eps,z)) / (2*eps);
  const dz = (F(x,y,z+eps) - F(x,y,z-eps)) / (2*eps);
  return {x:dx,y:dy,z:dz};
}

function normalize(v){
  const L = Math.hypot(v.x,v.y,v.z) || 1e-9;
  return {x:v.x/L,y:v.y/L,z:v.z/L};
}

const lightDir = normalize({x:0.0,y:0.5,z:1.0});

let lastTime = 0;
let angle = 0;

function renderFrame(dt){
  const aspect = W / H;
  const scale = 1.2;
  const xMul = scale * aspect;
  const yMul = scale;

  const zStart = 1.5, zEnd = -1.5;
  const zSteps = 60;
  const dz = (zStart - zEnd) / zSteps;

  let out = '';
  for(let j=0;j<H;j++){
    for(let i=0;i<W;i++){
      const nx = (i / (W-1) * 2 - 1) * xMul;
      const ny = (j / (H-1) * 2 - 1) * yMul;

      let hit = false;
      let prevF = null;
      let prevZ = zStart;
      let hitPosObj = null;

      for(let step=0; step<=zSteps; step++){
        const z = zStart - step * dz;
        const pObj = rotatePoint({x:nx, y:ny, z:z}, angle, angle*0.4);
        const f = F(pObj.x, pObj.y, pObj.z);
        if(step === 0){ prevF = f; prevZ = z; }
        if(Math.abs(f) < 1e-2){
          hit = true;
          hitPosObj = pObj;
          break;
        }
        if(prevF * f < 0){
          const t = prevF / (prevF - f);
          const zRoot = prevZ + t * (z - prevZ);
          hitPosObj = rotatePoint({x:nx,y:ny,z:zRoot}, angle, angle*0.4);
          hit = true;
          break;
        }
        prevF = f;
        prevZ = z;
      }

      if(hit && hitPosObj){
        const g = gradientAt(hitPosObj.x, hitPosObj.y, hitPosObj.z);
        const gw = rotateVecInverse(g, angle, angle*0.4);
        const normal = normalize(gw);
        let intensity = normal.x*lightDir.x + normal.y*lightDir.y + normal.z*lightDir.z;
        intensity = Math.max(0.0, Math.min(1.0, (intensity + 0.1)));
        const idx = Math.floor(intensity * (chars.length - 1));
        out += chars[idx];
      } else {
        out += ' ';
      }
    }
    out += '\n';
  }

  screen.textContent = out;
}

function loop(t){
  if(!running) {
    return;
  }
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  angle += dt * 1.0; // velocidad de rotaci칩n
  renderFrame(dt);
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

})();

const musica = document.getElementById("musica");
const musicBtn = document.getElementById("musicBtn");
let isPlaying = false;

musicBtn.addEventListener("click", () => {
  if (!isPlaying) {
    musica.muted = false;
    musica.volume = 0.3;
    musica.play().then(()=>{
      isPlaying = true;
      musicBtn.textContent = "游꿧";
      musicBtn.classList.remove("paused");
    });
  } else {
    musica.pause();
    isPlaying = false;
    musicBtn.textContent = "游댆";
    musicBtn.classList.add("paused");
  }
});
</script>
</body>
</html>